//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (TextTransform.exe) from the file IJobForEach.tt
//

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;

namespace Unity.Entities
{

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_C<,>))]
    #endif
    public interface IJobForEach<T0> : IJobForEach_C<T0>
		where T0 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EC<,>))]
    #endif
    public interface IJobForEachWithEntity<T0> : IJobForEachWithEntity_EC<T0>
		where T0 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CC<,,>))]
    #endif
    public interface IJobForEach<T0, T1> : IJobForEach_CC<T0, T1>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECC<,,>))]
    #endif
    public interface IJobForEachWithEntity<T0, T1> : IJobForEachWithEntity_ECC<T0, T1>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCC<,,,>))]
    #endif
    public interface IJobForEach<T0, T1, T2> : IJobForEach_CCC<T0, T1, T2>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCC<,,,>))]
    #endif
    public interface IJobForEachWithEntity<T0, T1, T2> : IJobForEachWithEntity_ECCC<T0, T1, T2>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCC<,,,,>))]
    #endif
    public interface IJobForEach<T0, T1, T2, T3> : IJobForEach_CCCC<T0, T1, T2, T3>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCC<,,,,>))]
    #endif
    public interface IJobForEachWithEntity<T0, T1, T2, T3> : IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCC<,,,,,>))]
    #endif
    public interface IJobForEach<T0, T1, T2, T3, T4> : IJobForEach_CCCCC<T0, T1, T2, T3, T4>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCC<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity<T0, T1, T2, T3, T4> : IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCCC<,,,,,,>))]
    #endif
    public interface IJobForEach<T0, T1, T2, T3, T4, T5> : IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCCC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity<T0, T1, T2, T3, T4, T5> : IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{}


#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_C<,>))]
    #endif
    public interface IJobForEach_C<T0> : JobForEachExtensions.IBaseJobForEach_C
		where T0 : struct, IComponentData
	{
        void Execute(ref T0 c0);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EC<,>))]
    #endif
    public interface IJobForEachWithEntity_EC<T0> : JobForEachExtensions.IBaseJobForEach_EC
		where T0 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_B<,>))]
    #endif
    public interface IJobForEach_B<T0> : JobForEachExtensions.IBaseJobForEach_B
		where T0 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EB<,>))]
    #endif
    public interface IJobForEachWithEntity_EB<T0> : JobForEachExtensions.IBaseJobForEach_EB
		where T0 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CC<,,>))]
    #endif
    public interface IJobForEach_CC<T0, T1> : JobForEachExtensions.IBaseJobForEach_CC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECC<,,>))]
    #endif
    public interface IJobForEachWithEntity_ECC<T0, T1> : JobForEachExtensions.IBaseJobForEach_ECC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BC<,,>))]
    #endif
    public interface IJobForEach_BC<T0, T1> : JobForEachExtensions.IBaseJobForEach_BC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBC<,,>))]
    #endif
    public interface IJobForEachWithEntity_EBC<T0, T1> : JobForEachExtensions.IBaseJobForEach_EBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BB<,,>))]
    #endif
    public interface IJobForEach_BB<T0, T1> : JobForEachExtensions.IBaseJobForEach_BB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBB<,,>))]
    #endif
    public interface IJobForEachWithEntity_EBB<T0, T1> : JobForEachExtensions.IBaseJobForEach_EBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCC<,,,>))]
    #endif
    public interface IJobForEach_CCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_CCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCC<,,,>))]
    #endif
    public interface IJobForEachWithEntity_ECCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_ECCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCC<,,,>))]
    #endif
    public interface IJobForEach_BCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_BCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCC<,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_EBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBC<,,,>))]
    #endif
    public interface IJobForEach_BBC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_BBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBC<,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_EBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBB<,,,>))]
    #endif
    public interface IJobForEach_BBB<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_BBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBB<,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBB<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_EBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCC<,,,,>))]
    #endif
    public interface IJobForEach_CCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_CCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCC<,,,,>))]
    #endif
    public interface IJobForEachWithEntity_ECCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_ECCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCCC<,,,,>))]
    #endif
    public interface IJobForEach_BCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCCC<,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBCC<,,,,>))]
    #endif
    public interface IJobForEach_BBCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBCC<,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBC<,,,,>))]
    #endif
    public interface IJobForEach_BBBC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBC<,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBB<,,,,>))]
    #endif
    public interface IJobForEach_BBBB<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBB<,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBB<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCC<,,,,,>))]
    #endif
    public interface IJobForEach_CCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_CCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCC<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_ECCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCCCC<,,,,,>))]
    #endif
    public interface IJobForEach_BCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCCCC<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBCCC<,,,,,>))]
    #endif
    public interface IJobForEach_BBCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBCCC<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBCC<,,,,,>))]
    #endif
    public interface IJobForEach_BBBCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBCC<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBC<,,,,,>))]
    #endif
    public interface IJobForEach_BBBBC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBC<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBBC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBB<,,,,,>))]
    #endif
    public interface IJobForEach_BBBBB<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBB<,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBBB<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCCC<,,,,,,>))]
    #endif
    public interface IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_CCCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCCC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_ECCCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCCCCC<,,,,,,>))]
    #endif
    public interface IJobForEach_BCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BCCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCCCCC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBCCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBCCCC<,,,,,,>))]
    #endif
    public interface IJobForEach_BBCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBCCCC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBCCC<,,,,,,>))]
    #endif
    public interface IJobForEach_BBBCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBCCC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBCC<,,,,,,>))]
    #endif
    public interface IJobForEach_BBBBCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBCC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBBCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBBC<,,,,,,>))]
    #endif
    public interface IJobForEach_BBBBBC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBBC<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBBBC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBBB<,,,,,,>))]
    #endif
    public interface IJobForEach_BBBBBB<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5);
    }

#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBBB<,,,,,,>))]
    #endif
    public interface IJobForEachWithEntity_EBBBBBB<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5);
    }


    public static partial class JobForEachExtensions
    {
#if !UNITY_DOTSPLAYER
        public static JobHandle Schedule<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle ScheduleSingle<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle Run<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_DOTSPLAYER
        public static JobHandle Schedule<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle ScheduleSingle<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle Run<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_C<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_C<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_C<,>), isParallelFor, ref JobStruct_ProcessInfer_C<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_C<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_C<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_C : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_C<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_C<T, T0>
            where T : struct, IJobForEach_C<T0>
            where T0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_C<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_C<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_C<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_C<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EC<,>), isParallelFor, ref JobStruct_ProcessInfer_EC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EC<T, T0>
            where T : struct, IJobForEachWithEntity_EC<T0>
            where T0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EC<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EC<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EC<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EC<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_B<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_B<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_B<,>), isParallelFor, ref JobStruct_ProcessInfer_B<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_B<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_B<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_B : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_B<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_B<T, T0>
            where T : struct, IJobForEach_B<T0>
            where T0 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_B<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_B<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_B<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_B<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EB<,>), isParallelFor, ref JobStruct_ProcessInfer_EB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EB<T, T0>
            where T : struct, IJobForEachWithEntity_EB<T0>
            where T0 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EB<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EB<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EB<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EB<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CC<,,>), isParallelFor, ref JobStruct_ProcessInfer_CC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CC<T, T0, T1>
            where T : struct, IJobForEach_CC<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECC<,,>), isParallelFor, ref JobStruct_ProcessInfer_ECC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECC<T, T0, T1>
            where T : struct, IJobForEachWithEntity_ECC<T0, T1>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BC<,,>), isParallelFor, ref JobStruct_ProcessInfer_BC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BC<T, T0, T1>
            where T : struct, IJobForEach_BC<T0, T1>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBC<,,>), isParallelFor, ref JobStruct_ProcessInfer_EBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBC<T, T0, T1>
            where T : struct, IJobForEachWithEntity_EBC<T0, T1>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BB<,,>), isParallelFor, ref JobStruct_ProcessInfer_BB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BB<T, T0, T1>
            where T : struct, IJobForEach_BB<T0, T1>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BB<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BB<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BB<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BB<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBB<,,>), isParallelFor, ref JobStruct_ProcessInfer_EBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBB<T, T0, T1>
            where T : struct, IJobForEachWithEntity_EBB<T0, T1>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBB<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBB<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBB<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBB<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCC<T, T0, T1, T2>
            where T : struct, IJobForEach_CCC<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCC<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCC<T, T0, T1, T2>
            where T : struct, IJobForEach_BCC<T0, T1, T2>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCC<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_EBCC<T0, T1, T2>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBC<T, T0, T1, T2>
            where T : struct, IJobForEach_BBC<T0, T1, T2>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBC<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_EBBC<T0, T1, T2>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBB<,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBB<T, T0, T1, T2>
            where T : struct, IJobForEach_BBB<T0, T1, T2>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBB<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBB<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBB<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBB<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBB<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBB<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_EBBB<T0, T1, T2>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBB<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBB<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBB<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBB<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_CCCC<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BCCC<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBCCC<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BBCC<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBBCC<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BBBC<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBBBC<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBB<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBB<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BBBB<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBB<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBB<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBB<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBB<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBB<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBB<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBBBB<T0, T1, T2, T3>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBB<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBB<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBB<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBB<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BCCCC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBCCCC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBCCC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBCCC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBBCC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBBCC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBBBC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBBBC<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBB<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBBBB<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
						var safety4 = jobData.Iterator.IsReadOnly4 != 0 ? 8 : jobData.Iterator.m_SafetyReadOnlyCount + 8;
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, safety[safety4], safety[safety4 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBB<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBBBB<T0, T1, T2, T3, T4>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
						var safety4 = jobData.Iterator.IsReadOnly4 != 0 ? 8 : jobData.Iterator.m_SafetyReadOnlyCount + 8;
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, safety[safety4], safety[safety4 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
						var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BCCCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBCCCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBCCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBCCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBCCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBBCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBBCC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBBC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBBBC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
						var safety4 = jobData.Iterator.IsReadOnly4 != 0 ? 8 : jobData.Iterator.m_SafetyReadOnlyCount + 8;
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, safety[safety4], safety[safety4 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBBC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBBBC<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
						var safety4 = jobData.Iterator.IsReadOnly4 != 0 ? 8 : jobData.Iterator.m_SafetyReadOnlyCount + 8;
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, safety[safety4], safety[safety4 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif
						var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBBB<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBBBB<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
						var safety4 = jobData.Iterator.IsReadOnly4 != 0 ? 8 : jobData.Iterator.m_SafetyReadOnlyCount + 8;
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, safety[safety4], safety[safety4 + 1]);
						var safety5 = jobData.Iterator.IsReadOnly5 != 0 ? 10 : jobData.Iterator.m_SafetyReadOnlyCount + 10;
						var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion, safety[safety5], safety[safety5 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
						var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], buffer5[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBBB<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBBBB<T0, T1, T2, T3, T4, T5>
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {
						var safety0 = jobData.Iterator.IsReadOnly0 != 0 ? 0 : jobData.Iterator.m_SafetyReadOnlyCount + 0;
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, safety[safety0], safety[safety0 + 1]);
						var safety1 = jobData.Iterator.IsReadOnly1 != 0 ? 2 : jobData.Iterator.m_SafetyReadOnlyCount + 2;
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, safety[safety1], safety[safety1 + 1]);
						var safety2 = jobData.Iterator.IsReadOnly2 != 0 ? 4 : jobData.Iterator.m_SafetyReadOnlyCount + 4;
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, safety[safety2], safety[safety2 + 1]);
						var safety3 = jobData.Iterator.IsReadOnly3 != 0 ? 6 : jobData.Iterator.m_SafetyReadOnlyCount + 6;
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, safety[safety3], safety[safety3 + 1]);
						var safety4 = jobData.Iterator.IsReadOnly4 != 0 ? 8 : jobData.Iterator.m_SafetyReadOnlyCount + 8;
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, safety[safety4], safety[safety4 + 1]);
						var safety5 = jobData.Iterator.IsReadOnly5 != 0 ? 10 : jobData.Iterator.m_SafetyReadOnlyCount + 10;
						var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion, safety[safety5], safety[safety5 + 1]);
#else
						var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
						var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
						var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
						var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
						var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
						var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion);
#endif


                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], buffer5[i]);
                        }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
                }
            }
        }
#endif


    }
}

