//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by EntityQueryBuilder.tt (129 `foreach` combinations)

using System;
using System.ComponentModel;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace Unity.Entities
{
    public partial struct EntityQueryBuilder
    {
        public delegate void F_E(Entity entity);

        public unsafe void ForEach(F_E action)
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {

                var query = m_Query;
                if (query == null)
                {
                    query = ResolveEntityQuery(null, 0);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        action(entity);
                    }
                }
            }
        }

        public delegate void F_ED<T0>(Entity entity, ref T0 d0)
            where T0 : struct, IComponentData;

        public unsafe void ForEach<T0>(F_ED<T0> action)
            where T0 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        action(entity, ref c0);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_D<T0>(ref T0 d0)
            where T0 : struct, IComponentData;

        public unsafe void ForEach<T0>(F_D<T0> action)
            where T0 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        action(ref c0);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EC<T0>(Entity entity, T0 c0)
            where T0 : class;

        public unsafe void ForEach<T0>(F_EC<T0> action)
            where T0 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        action(entity, c0);
                    }
                }
            }
        }

        public delegate void F_C<T0>(T0 c0)
            where T0 : class;

        public unsafe void ForEach<T0>(F_C<T0> action)
            where T0 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        action(c0);
                    }
                }
            }
        }

        public delegate void F_EB<T0>(Entity entity, DynamicBuffer<T0> b0)
            where T0 : struct, IBufferElementData;

        public unsafe void ForEach<T0>(F_EB<T0> action)
            where T0 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        action(entity, c0);
                    }
                }
            }
        }

        public delegate void F_B<T0>(DynamicBuffer<T0> b0)
            where T0 : struct, IBufferElementData;

        public unsafe void ForEach<T0>(F_B<T0> action)
            where T0 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        action(c0);
                    }
                }
            }
        }

        public delegate void F_ES<T0>(Entity entity, T0 s0)
            where T0 : struct, ISharedComponentData;

        public unsafe void ForEach<T0>(F_ES<T0> action)
            where T0 : struct, ISharedComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        action(entity, c0);
                    }
                }
            }
        }

        public delegate void F_S<T0>(T0 s0)
            where T0 : struct, ISharedComponentData;

        public unsafe void ForEach<T0>(F_S<T0> action)
            where T0 : struct, ISharedComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0 };
                    query = ResolveEntityQuery(delegateTypes, 1);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        action(c0);
                    }
                }
            }
        }

        public delegate void F_EDD<T0, T1>(Entity entity, ref T0 d0, ref T1 d1)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_EDD<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(entity, ref c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DD<T0, T1>(ref T0 d0, ref T1 d1)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_DD<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(ref c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDDD<T0, T1, T2>(Entity entity, ref T0 d0, ref T1 d1, ref T2 d2)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_EDDD<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(entity, ref c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DDD<T0, T1, T2>(ref T0 d0, ref T1 d1, ref T2 d2)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_DDD<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(ref c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDDDD<T0, T1, T2, T3>(Entity entity, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EDDDD<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(entity, ref c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DDDD<T0, T1, T2, T3>(ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_DDDD<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(ref c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDDDDD<T0, T1, T2, T3, T4>(Entity entity, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EDDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(entity, ref c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DDDDD<T0, T1, T2, T3, T4>(ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_DDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(ref c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EDDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(entity, ref c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DDDDDD<T0, T1, T2, T3, T4, T5>(ref T0 d0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_DDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(ref c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECD<T0, T1>(Entity entity, T0 c0, ref T1 d1)
            where T0 : class
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_ECD<T0, T1> action)
            where T0 : class
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(entity, c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_CD<T0, T1>(T0 c0, ref T1 d1)
            where T0 : class
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_CD<T0, T1> action)
            where T0 : class
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECDD<T0, T1, T2>(Entity entity, T0 c0, ref T1 d1, ref T2 d2)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_ECDD<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(entity, c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_CDD<T0, T1, T2>(T0 c0, ref T1 d1, ref T2 d2)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_CDD<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECDDD<T0, T1, T2, T3>(Entity entity, T0 c0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ECDDD<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(entity, c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_CDDD<T0, T1, T2, T3>(T0 c0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_CDDD<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECDDDD<T0, T1, T2, T3, T4>(Entity entity, T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ECDDDD<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(entity, c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_CDDDD<T0, T1, T2, T3, T4>(T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_CDDDD<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ECDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(entity, c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_CDDDDD<T0, T1, T2, T3, T4, T5>(T0 c0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_CDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EBD<T0, T1>(Entity entity, DynamicBuffer<T0> b0, ref T1 d1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_EBD<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(entity, c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_BD<T0, T1>(DynamicBuffer<T0> b0, ref T1 d1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_BD<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EBDD<T0, T1, T2>(Entity entity, DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_EBDD<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(entity, c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_BDD<T0, T1, T2>(DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_BDD<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EBDDD<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EBDDD<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(entity, c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_BDDD<T0, T1, T2, T3>(DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_BDDD<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EBDDDD<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EBDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(entity, c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_BDDDD<T0, T1, T2, T3, T4>(DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_BDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EBDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EBDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(entity, c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_BDDDDD<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> b0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_BDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ESD<T0, T1>(Entity entity, T0 s0, ref T1 d1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_ESD<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(entity, c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_SD<T0, T1>(T0 s0, ref T1 d1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData;

        public unsafe void ForEach<T0, T1>(F_SD<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        action(c0, ref c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ESDD<T0, T1, T2>(Entity entity, T0 s0, ref T1 d1, ref T2 d2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_ESDD<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(entity, c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_SDD<T0, T1, T2>(T0 s0, ref T1 d1, ref T2 d2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2>(F_SDD<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        action(c0, ref c1, ref c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ESDDD<T0, T1, T2, T3>(Entity entity, T0 s0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ESDDD<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(entity, c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_SDDD<T0, T1, T2, T3>(T0 s0, ref T1 d1, ref T2 d2, ref T3 d3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_SDDD<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        action(c0, ref c1, ref c2, ref c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ESDDDD<T0, T1, T2, T3, T4>(Entity entity, T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ESDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(entity, c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_SDDDD<T0, T1, T2, T3, T4>(T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_SDDDD<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        action(c0, ref c1, ref c2, ref c3, ref c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ESDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ESDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(entity, c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_SDDDDD<T0, T1, T2, T3, T4, T5>(T0 s0, ref T1 d1, ref T2 d2, ref T3 d3, ref T4 d4, ref T5 d5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_SDDDDD<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IComponentData
            where T2 : struct, IComponentData
            where T3 : struct, IComponentData
            where T4 : struct, IComponentData
            where T5 : struct, IComponentData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex1), out T1 c1);
                        var copy1 = c1;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex2), out T2 c2);
                        var copy2 = c2;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex3), out T3 c3);
                        var copy3 = c3;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex4), out T4 c4);
                        var copy4 = c4;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex5), out T5 c5);
                        var copy5 = c5;
                        action(c0, ref c1, ref c2, ref c3, ref c4, ref c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy1), UnsafeUtility.AddressOf(ref c1), UnsafeUtility.SizeOf<T1>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex1))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c1, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex1,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy2), UnsafeUtility.AddressOf(ref c2), UnsafeUtility.SizeOf<T2>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex2))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c2, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex2,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy3), UnsafeUtility.AddressOf(ref c3), UnsafeUtility.SizeOf<T3>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex3))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c3, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex3,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy4), UnsafeUtility.AddressOf(ref c4), UnsafeUtility.SizeOf<T4>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex4))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c4, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex4,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy5), UnsafeUtility.AddressOf(ref c5), UnsafeUtility.SizeOf<T5>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex5))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c5, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex5,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDC<T0, T1>(Entity entity, ref T0 d0, T1 c1)
            where T0 : struct, IComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_EDC<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(entity, ref c0, c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DC<T0, T1>(ref T0 d0, T1 c1)
            where T0 : struct, IComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_DC<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(ref c0, c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDCC<T0, T1, T2>(Entity entity, ref T0 d0, T1 c1, T2 c2)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_EDCC<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(entity, ref c0, c1, c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DCC<T0, T1, T2>(ref T0 d0, T1 c1, T2 c2)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_DCC<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(ref c0, c1, c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDCCC<T0, T1, T2, T3>(Entity entity, ref T0 d0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EDCCC<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(entity, ref c0, c1, c2, c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DCCC<T0, T1, T2, T3>(ref T0 d0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_DCCC<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(ref c0, c1, c2, c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDCCCC<T0, T1, T2, T3, T4>(Entity entity, ref T0 d0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EDCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(entity, ref c0, c1, c2, c3, c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DCCCC<T0, T1, T2, T3, T4>(ref T0 d0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_DCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(ref c0, c1, c2, c3, c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 d0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EDCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(entity, ref c0, c1, c2, c3, c4, c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DCCCCC<T0, T1, T2, T3, T4, T5>(ref T0 d0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_DCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(ref c0, c1, c2, c3, c4, c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECC<T0, T1>(Entity entity, T0 c0, T1 c1)
            where T0 : class
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_ECC<T0, T1> action)
            where T0 : class
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(entity, c0, c1);
                    }
                }
            }
        }

        public delegate void F_CC<T0, T1>(T0 c0, T1 c1)
            where T0 : class
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_CC<T0, T1> action)
            where T0 : class
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(c0, c1);
                    }
                }
            }
        }

        public delegate void F_ECCC<T0, T1, T2>(Entity entity, T0 c0, T1 c1, T2 c2)
            where T0 : class
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_ECCC<T0, T1, T2> action)
            where T0 : class
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(entity, c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_CCC<T0, T1, T2>(T0 c0, T1 c1, T2 c2)
            where T0 : class
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_CCC<T0, T1, T2> action)
            where T0 : class
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_ECCCC<T0, T1, T2, T3>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ECCCC<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(entity, c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_CCCC<T0, T1, T2, T3>(T0 c0, T1 c1, T2 c2, T3 c3)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_CCCC<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_ECCCCC<T0, T1, T2, T3, T4>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ECCCCC<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(entity, c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_CCCCC<T0, T1, T2, T3, T4>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_CCCCC<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_ECCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ECCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(entity, c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_CCCCCC<T0, T1, T2, T3, T4, T5>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_CCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_EBC<T0, T1>(Entity entity, DynamicBuffer<T0> b0, T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_EBC<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(entity, c0, c1);
                    }
                }
            }
        }

        public delegate void F_BC<T0, T1>(DynamicBuffer<T0> b0, T1 c1)
            where T0 : struct, IBufferElementData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_BC<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(c0, c1);
                    }
                }
            }
        }

        public delegate void F_EBCC<T0, T1, T2>(Entity entity, DynamicBuffer<T0> b0, T1 c1, T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_EBCC<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(entity, c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_BCC<T0, T1, T2>(DynamicBuffer<T0> b0, T1 c1, T2 c2)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_BCC<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_EBCCC<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> b0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EBCCC<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(entity, c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_BCCC<T0, T1, T2, T3>(DynamicBuffer<T0> b0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_BCCC<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_EBCCCC<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> b0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EBCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(entity, c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_BCCCC<T0, T1, T2, T3, T4>(DynamicBuffer<T0> b0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_BCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_EBCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> b0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EBCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(entity, c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_BCCCCC<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> b0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_BCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_ESC<T0, T1>(Entity entity, T0 s0, T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_ESC<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(entity, c0, c1);
                    }
                }
            }
        }

        public delegate void F_SC<T0, T1>(T0 s0, T1 c1)
            where T0 : struct, ISharedComponentData
            where T1 : class;

        public unsafe void ForEach<T0, T1>(F_SC<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        action(c0, c1);
                    }
                }
            }
        }

        public delegate void F_ESCC<T0, T1, T2>(Entity entity, T0 s0, T1 c1, T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_ESCC<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(entity, c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_SCC<T0, T1, T2>(T0 s0, T1 c1, T2 c2)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class;

        public unsafe void ForEach<T0, T1, T2>(F_SCC<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        action(c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_ESCCC<T0, T1, T2, T3>(Entity entity, T0 s0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ESCCC<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(entity, c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_SCCC<T0, T1, T2, T3>(T0 s0, T1 c1, T2 c2, T3 c3)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class;

        public unsafe void ForEach<T0, T1, T2, T3>(F_SCCC<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        action(c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_ESCCCC<T0, T1, T2, T3, T4>(Entity entity, T0 s0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ESCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(entity, c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_SCCCC<T0, T1, T2, T3, T4>(T0 s0, T1 c1, T2 c2, T3 c3, T4 c4)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_SCCCC<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        action(c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_ESCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, T0 s0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ESCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(entity, c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_SCCCCC<T0, T1, T2, T3, T4, T5>(T0 s0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_SCCCCC<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where T5 : class
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetComponentObject<T1>(entity);
                        var c2 = m_System.EntityManager.GetComponentObject<T2>(entity);
                        var c3 = m_System.EntityManager.GetComponentObject<T3>(entity);
                        var c4 = m_System.EntityManager.GetComponentObject<T4>(entity);
                        var c5 = m_System.EntityManager.GetComponentObject<T5>(entity);
                        action(c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_EDB<T0, T1>(Entity entity, ref T0 d0, DynamicBuffer<T1> b1)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_EDB<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(entity, ref c0, c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DB<T0, T1>(ref T0 d0, DynamicBuffer<T1> b1)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_DB<T0, T1> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(ref c0, c1);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDBB<T0, T1, T2>(Entity entity, ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_EDBB<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(entity, ref c0, c1, c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DBB<T0, T1, T2>(ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_DBB<T0, T1, T2> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(ref c0, c1, c2);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDBBB<T0, T1, T2, T3>(Entity entity, ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EDBBB<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(entity, ref c0, c1, c2, c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DBBB<T0, T1, T2, T3>(ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_DBBB<T0, T1, T2, T3> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(ref c0, c1, c2, c3);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDBBBB<T0, T1, T2, T3, T4>(Entity entity, ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EDBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(entity, ref c0, c1, c2, c3, c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DBBBB<T0, T1, T2, T3, T4>(ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_DBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(ref c0, c1, c2, c3, c4);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_EDBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EDBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(entity, ref c0, c1, c2, c3, c4, c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_DBBBBB<T0, T1, T2, T3, T4, T5>(ref T0 d0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_DBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        UnsafeUtility.CopyPtrToStructure(m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRO(entity, typeIndex0), out T0 c0);
                        var copy0 = c0;
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(ref c0, c1, c2, c3, c4, c5);
                        if (UnsafeUtility.MemCmp(UnsafeUtility.AddressOf(ref copy0), UnsafeUtility.AddressOf(ref c0), UnsafeUtility.SizeOf<T0>()) != 0 &&
                            m_System.EntityManager.EntityComponentStore->HasComponent(entity, typeIndex0))
                        {
                            UnsafeUtility.CopyStructureToPtr(ref c0, m_System.EntityManager.EntityComponentStore->GetComponentDataWithTypeRW(entity, typeIndex0,
                                m_System.EntityManager.EntityComponentStore->GlobalSystemVersion));
                        }
                    }
                }
            }
        }

        public delegate void F_ECB<T0, T1>(Entity entity, T0 c0, DynamicBuffer<T1> b1)
            where T0 : class
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_ECB<T0, T1> action)
            where T0 : class
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(entity, c0, c1);
                    }
                }
            }
        }

        public delegate void F_CB<T0, T1>(T0 c0, DynamicBuffer<T1> b1)
            where T0 : class
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_CB<T0, T1> action)
            where T0 : class
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(c0, c1);
                    }
                }
            }
        }

        public delegate void F_ECBB<T0, T1, T2>(Entity entity, T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_ECBB<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(entity, c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_CBB<T0, T1, T2>(T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_CBB<T0, T1, T2> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_ECBBB<T0, T1, T2, T3>(Entity entity, T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ECBBB<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(entity, c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_CBBB<T0, T1, T2, T3>(T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_CBBB<T0, T1, T2, T3> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_ECBBBB<T0, T1, T2, T3, T4>(Entity entity, T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ECBBBB<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(entity, c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_CBBBB<T0, T1, T2, T3, T4>(T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_CBBBB<T0, T1, T2, T3, T4> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_ECBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ECBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(entity, c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_CBBBBB<T0, T1, T2, T3, T4, T5>(T0 c0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_CBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : class
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetComponentObject<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_EBB<T0, T1>(Entity entity, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_EBB<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(entity, c0, c1);
                    }
                }
            }
        }

        public delegate void F_BB<T0, T1>(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_BB<T0, T1> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(c0, c1);
                    }
                }
            }
        }

        public delegate void F_EBBB<T0, T1, T2>(Entity entity, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_EBBB<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(entity, c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_BBB<T0, T1, T2>(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_BBB<T0, T1, T2> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_EBBBB<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_EBBBB<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(entity, c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_BBBB<T0, T1, T2, T3>(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_BBBB<T0, T1, T2, T3> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_EBBBBB<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_EBBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(entity, c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_BBBBB<T0, T1, T2, T3, T4>(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_BBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_EBBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_EBBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(entity, c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_BBBBBB<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_BBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, IBufferElementData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetBuffer<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_ESB<T0, T1>(Entity entity, T0 s0, DynamicBuffer<T1> b1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_ESB<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(entity, c0, c1);
                    }
                }
            }
        }

        public delegate void F_SB<T0, T1>(T0 s0, DynamicBuffer<T1> b1)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1>(F_SB<T0, T1> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1 };
                    query = ResolveEntityQuery(delegateTypes, 2);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        action(c0, c1);
                    }
                }
            }
        }

        public delegate void F_ESBB<T0, T1, T2>(Entity entity, T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_ESBB<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(entity, c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_SBB<T0, T1, T2>(T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2>(F_SBB<T0, T1, T2> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2 };
                    query = ResolveEntityQuery(delegateTypes, 3);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        action(c0, c1, c2);
                    }
                }
            }
        }

        public delegate void F_ESBBB<T0, T1, T2, T3>(Entity entity, T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_ESBBB<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(entity, c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_SBBB<T0, T1, T2, T3>(T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3>(F_SBBB<T0, T1, T2, T3> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3 };
                    query = ResolveEntityQuery(delegateTypes, 4);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        action(c0, c1, c2, c3);
                    }
                }
            }
        }

        public delegate void F_ESBBBB<T0, T1, T2, T3, T4>(Entity entity, T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_ESBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(entity, c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_SBBBB<T0, T1, T2, T3, T4>(T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4>(F_SBBBB<T0, T1, T2, T3, T4> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4 };
                    query = ResolveEntityQuery(delegateTypes, 5);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        action(c0, c1, c2, c3, c4);
                    }
                }
            }
        }

        public delegate void F_ESBBBBB<T0, T1, T2, T3, T4, T5>(Entity entity, T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_ESBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(entity, c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

        public delegate void F_SBBBBB<T0, T1, T2, T3, T4, T5>(T0 s0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData;

        public unsafe void ForEach<T0, T1, T2, T3, T4, T5>(F_SBBBBB<T0, T1, T2, T3, T4, T5> action)
            where T0 : struct, ISharedComponentData
            where T1 : struct, IBufferElementData
            where T2 : struct, IBufferElementData
            where T3 : struct, IBufferElementData
            where T4 : struct, IBufferElementData
            where T5 : struct, IBufferElementData
        {
            #if ENABLE_UNITY_COLLECTIONS_CHECKS
            using (InsideForEach())
            #endif
            {
                var typeIndex0 = TypeManager.GetTypeIndex<T0>();
                var typeIndex1 = TypeManager.GetTypeIndex<T1>();
                var typeIndex2 = TypeManager.GetTypeIndex<T2>();
                var typeIndex3 = TypeManager.GetTypeIndex<T3>();
                var typeIndex4 = TypeManager.GetTypeIndex<T4>();
                var typeIndex5 = TypeManager.GetTypeIndex<T5>();

                var query = m_Query;
                if (query == null)
                {
                    var delegateTypes = stackalloc[] { typeIndex0, typeIndex1, typeIndex2, typeIndex3, typeIndex4, typeIndex5 };
                    query = ResolveEntityQuery(delegateTypes, 6);
                }
                using (var originalEntities = query.ToEntityArray(Allocator.TempJob))
                {
                    for (var entityCount = 0; entityCount < originalEntities.Length; entityCount++)
                    {
                        var entity = originalEntities[entityCount];
                        if (!m_System.EntityManager.Exists(entity))
                            continue;
                        var c0 = m_System.EntityManager.GetSharedComponentData<T0>(entity);
                        var c1 = m_System.EntityManager.GetBuffer<T1>(entity);
                        var c2 = m_System.EntityManager.GetBuffer<T2>(entity);
                        var c3 = m_System.EntityManager.GetBuffer<T3>(entity);
                        var c4 = m_System.EntityManager.GetBuffer<T4>(entity);
                        var c5 = m_System.EntityManager.GetBuffer<T5>(entity);
                        action(c0, c1, c2, c3, c4, c5);
                    }
                }
            }
        }

    }

} // namespace Unity.Entities

