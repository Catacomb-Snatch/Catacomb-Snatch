<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ output extension=".gen.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (TextTransform.exe) from the file IJobForEach.tt
//

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;

namespace Unity.Entities
{

<#
var basicCombinations = GenCombinations();
foreach(var combination in basicCombinations) {
    foreach (var withEntity in new[] { false, true }) {
        if(combination[0] == Category.B)
            continue;
        var comboString = GetComboString(withEntity, combination);
        var name = GetName(withEntity, comboString);
#>
<#=BasicInterface(combination, withEntity, comboString)#>

<#
    }
}
#>

<#
var combinations = GenCombinations();
foreach(var combination in combinations) {
    foreach (var withEntity in new[] { false, true }) {
        var comboString = GetComboString(withEntity, combination);
#>
<#=Interface(combination, withEntity, comboString)#>

<#
    }
}
#>

    public static partial class JobForEachExtensions
    {
<#
string[] funcNames = new string[]{"Schedule", "ScheduleSingle", "Run"};
int [] forEachVals = new int[]{1, -1, -1};
string[] scheduleMode = new string[]{"ScheduleMode.Batched", "ScheduleMode.Batched", "ScheduleMode.Run"};
for(int i=0; i<funcNames.Length; ++i) {
#>
#if !UNITY_DOTSPLAYER
        public static JobHandle <#=funcNames[i]#><T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
<#
    foreach(var combination in combinations) {
        var comboStringD = GetComboString(false, combination);
        var comboStringE = GetComboString(true, combination);
#>
            if (typeof(IBaseJobForEach_<#=comboStringD#>).IsAssignableFrom(typeT))
                return ScheduleInternal_<#=comboStringD#>(ref jobData, system, null, <#=forEachVals[i]#>, dependsOn, <#=scheduleMode[i]#>);
            if (typeof(IBaseJobForEach_<#=comboStringE#>).IsAssignableFrom(typeT))
                return ScheduleInternal_<#=comboStringE#>(ref jobData, system, null, <#=forEachVals[i]#>, dependsOn, <#=scheduleMode[i]#>);
<#
    }
#>
            throw new System.ArgumentException("Not supported");
        }
#endif
<#
}
#>

<#
string[] groupFuncNames = new string[]{"Schedule", "ScheduleSingle", "Run"};
for(int i=0; i<funcNames.Length; ++i) {
#>
#if !UNITY_DOTSPLAYER
        public static JobHandle <#=groupFuncNames[i]#><T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
<#
    foreach(var combination in combinations) {
        var comboStringD = GetComboString(false, combination);
        var comboStringE = GetComboString(true, combination);
#>
            if (typeof(IBaseJobForEach_<#=comboStringD#>).IsAssignableFrom(typeT))
                return ScheduleInternal_<#=comboStringD#>(ref jobData, null, query, <#=forEachVals[i]#>, dependsOn, <#=scheduleMode[i]#>);
            if (typeof(IBaseJobForEach_<#=comboStringE#>).IsAssignableFrom(typeT))
                return ScheduleInternal_<#=comboStringE#>(ref jobData, null, query, <#=forEachVals[i]#>, dependsOn, <#=scheduleMode[i]#>);
<#
    }
#>
            throw new System.ArgumentException("Not supported");
        }
#endif
<#
}
#>

<#
foreach(var combination in combinations) {
    foreach (var withEntity in new[] { false, true }) {
        var comboString = GetComboString(withEntity, combination);
        var untypedGenericParams = new StringBuilder();
        var genericParams = new StringBuilder();
        var genericConstraints = GenericConstraints(combination);

        var executeParams = ExecuteParams(withEntity, combination);
        var executeCallParams = ExecuteCallParams(withEntity, combination);
        var ptrs = DataAccessors(withEntity, combination);
        var typeLookupCache = new StringBuilder();

        var interfaceName = GetName(withEntity, comboString);

        for (int i = 0; i != combination.Length; i++)
        {

            typeLookupCache.AppendLine($@"				var typeLookupCache{i} = 0;");

            untypedGenericParams.Append(",");

            genericParams.Append($"T{i}");
            if (i != combination.Length - 1)
                genericParams.Append(", ");
        }
#>
#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_<#=comboString#><T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_<#=comboString#><T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_<#=comboString#><<#=untypedGenericParams#>>), isParallelFor, ref JobStruct_ProcessInfer_<#=comboString#><T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_<#=comboString#><T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_<#=comboString#><T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_<#=comboString#> : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_<#=comboString#><T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_<#=comboString#><T, <#=genericParams#>>
            where T : struct, <#=interfaceName#><<#=genericParams#>>
<#
    foreach(var constraint in genericConstraints){
#>
            <#=constraint#>
<#
    }
#>
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_<#=comboString#><T, <#=genericParams#>>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_<#=comboString#><T, <#=genericParams#>> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_<#=comboString#><T, <#=genericParams#>> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_<#=comboString#><T, <#=genericParams#>> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
<#=typeLookupCache#>
                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
<#=ptrs#>

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(<#=executeCallParams#>);
                        }
<# if(combination[0] == Category.B) {#>
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    }
#endif
<# } #>
                }
            }
        }
#endif

<#
    }
}
#>

    }
}

<#+
// keep these alphabetical as a general rule
enum Category
{
    B,  // IBufferElementData
    C   // IComponentData
}

List<Category[]> GenCombinations()
{
    var combinations = new List<Category[]>();

    var categories = Enum.GetValues(typeof(Category));

    for(int combinationLength = 1; combinationLength <= 6; ++combinationLength)
    {
        for(int numBs = 0; numBs <= combinationLength; ++numBs)
        {
            var array = new Category[combinationLength];

            for(int i = 0; i < numBs; ++i)
            {
                array[i] = Category.B;
            }

            var numCs = combinationLength - numBs;
            for(int i = 0; i < numCs; ++i)
            {
                array[numBs + i] = Category.C;
            }

            combinations.Add(array);
        }

    }

    return combinations;
}

string GetComboString(bool withEntity, Category[] combination)
{
    var baseType = new StringBuilder();

    if (withEntity)
        baseType.Append("E");
    foreach (var c in combination)
        baseType.Append(Enum.GetName(typeof(Category), c));
    return baseType.ToString();
}

string GetName(bool withEntity, string comboString)
{
    var name = new StringBuilder();

    name.Append("IJobForEach");
    if (withEntity)
        name.Append("WithEntity");

    name.Append("_");
    name.Append(comboString);

    return name.ToString();
}

string GetUntypedGenericParams(Category[] combination) {
    return new String(',', combination.Length);
}

string GenericParams(Category[] combination) {
    StringBuilder genericParams = new StringBuilder();
    for(int i=0; i<combination.Length; ++i) {
        genericParams.Append($"T{i}");
        if (i != combination.Length - 1)
            genericParams.Append(", ");
    }
    return genericParams.ToString();
}

string[] _GenericConstraints =
{
    "where T{0} : struct, IBufferElementData",   // IBufferElementData
    "where T{0} : struct, IComponentData",       // ref ComponentData
};

IEnumerable<string> GenericConstraints(Category[] categories) =>
    categories.Select((c, i) => string.Format(_GenericConstraints[(int)c], i));

string ExecuteParams(bool withEntity, Category[] combination)
{
    var executeParams = new StringBuilder();
    if (withEntity) {
        executeParams.Append("Entity entity, int index, ");
    }
    for(int i=0; i<combination.Length; ++i)
    {
        if(combination[i] == Category.C)
            executeParams.Append($"ref T{i} c{i}");
        else if(combination[i] == Category.B)
            executeParams.Append($"DynamicBuffer<T{i}> b{i}");

        if (i != combination.Length - 1)
            executeParams.Append(", ");
    }
    return executeParams.ToString();
}

string ExecuteCallParams(bool withEntity, Category[] combination)
{
    var callParams = new StringBuilder();

    if (withEntity)
    {
        callParams.Append($"ptrE[i], i + beginIndex, ");
    }

    for(int i=0; i<combination.Length; ++i)
    {
        if(combination[i] == Category.C)
                callParams.Append($"ref UnsafeUtilityEx.ArrayElementAsRef<T{i}>(ptr{i}, i)");
        else if(combination[i] == Category.B)
            callParams.Append($"buffer{i}[i]");

        if (i != combination.Length - 1)
            callParams.Append(", ");
    }
    return callParams.ToString();
}

string DataAccessors(bool withEntity, Category[] combination)
{
    var accessors = new StringBuilder();

    if (withEntity)
    {
        accessors.AppendLine
        (
$"					var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));"
        );
    }

    for (int i = 0; i != combination.Length; i++)
    {
        accessors.AppendLine($"					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex{i}, ref typeLookupCache{i});"					);
    }

    bool insertSafetyChecks = (combination[0] == Category.B);
    if(insertSafetyChecks)
        accessors.AppendLine($@"#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    fixed (AtomicSafetyHandle* safety = &jobData.Iterator.m_Safety0)
                    {{");

    int numBs = 0;
    for(;numBs < combination.Length; ++numBs)
    {
        if(combination[numBs] != Category.B)
            break;

        accessors.AppendLine($@"						var safety{numBs} = jobData.Iterator.IsReadOnly{numBs} != 0 ? {numBs * 2} : jobData.Iterator.m_SafetyReadOnlyCount + {numBs * 2};");
        accessors.AppendLine($@"						var buffer{numBs} = ComponentChunkIterator.GetChunkBufferAccessor<T{numBs}>(chunk.m_Chunk, jobData.Iterator.IsReadOnly{numBs} == 0, typeLookupCache{numBs}, jobData.Iterator.GlobalSystemVersion, safety[safety{numBs}], safety[safety{numBs} + 1]);");
    }

    if(insertSafetyChecks)
        accessors.AppendLine("#else");

    for(int i = 0; i < numBs; ++i)
        accessors.AppendLine($@"						var buffer{i} = ComponentChunkIterator.GetChunkBufferAccessor<T{i}>(chunk.m_Chunk, jobData.Iterator.IsReadOnly{i} == 0, typeLookupCache{i}, jobData.Iterator.GlobalSystemVersion);");

    if(insertSafetyChecks)
        accessors.AppendLine("#endif");

    int numCs = combination.Length - numBs;
    for(int i = numBs; i < combination.Length; ++i)
    {
        accessors.AppendLine($@"						var ptr{i} = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly{i} == 0, typeLookupCache{i}, jobData.Iterator.GlobalSystemVersion));");
    }

    return accessors.ToString();
}

string Interface( Category[] combination, bool withEntity, string comboString )
{
    var name = GetName(withEntity, comboString);
    var interfaceDec = new StringBuilder();

    interfaceDec.Append(
$@"#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_{comboString}<{GetUntypedGenericParams(combination)}>))]
    #endif
    public interface {name}<{GenericParams(combination)}> : JobForEachExtensions.IBaseJobForEach_{comboString}
");

    var genericConstraints = GenericConstraints(combination);
    foreach(var constraint in genericConstraints)
    {
        interfaceDec.AppendLine("		" + constraint);
    }

    interfaceDec.Append($@"	{{
        void Execute({ExecuteParams(withEntity, combination)});
    }}");
    return interfaceDec.ToString();
}

string BasicInterface( Category[] combination, bool withEntity, string comboString )
{
    var name = withEntity ? "IJobForEachWithEntity" : "IJobForEach";
    var interfaceDec = new StringBuilder();

    interfaceDec.AppendLine(
    $@"#if !UNITY_ZEROPLAYER
    [JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_{comboString}<{GetUntypedGenericParams(combination)}>))]
    #endif
    public interface {name}<{GenericParams(combination)}> : {name}_{comboString}<{GenericParams(combination)}>");

    var genericConstraints = GenericConstraints(combination);
    foreach(var constraint in genericConstraints)
    {
        interfaceDec.AppendLine("		" + constraint);
    }

    interfaceDec.Append($@"	{{}}");
    return interfaceDec.ToString();
}

static string Series(string formatString, int count, string separator) =>
    string.Join(separator, Enumerable.Range(0, count).Select(i => string.Format(formatString, i)));

#>
