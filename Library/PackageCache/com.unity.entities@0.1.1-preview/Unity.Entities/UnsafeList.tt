<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.entities/Unity.Entities/UnsafeList.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace Unity.Entities
{
<#
{
    foreach (var (type, typeName) in new[] {
        ( "int",  "Int"  ),
        ( "uint", "Uint" ),
    }) {
#>
    [DebuggerTypeProxy(typeof(Unsafe<#=typeName#>ListDebugView))]
    internal unsafe struct Unsafe<#=typeName#>List
    {
        [NativeDisableUnsafePtrRestriction]
        public readonly <#=type#>* Ptr;
        public readonly int Length;
        public readonly int Capacity;
        public readonly Allocator Allocator;

        private ref UnsafeList ListData { get { return ref *(UnsafeList*)UnsafeUtility.AddressOf(ref this); } }

        public unsafe Unsafe<#=typeName#>List(int initialCapacity, Allocator allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { Ptr = null; Length = 0; Capacity = 0; Allocator = Allocator.Invalid; ListData = new UnsafeList(UnsafeUtility.SizeOf<<#=type#>>(), UnsafeUtility.AlignOf<<#=type#>>(), initialCapacity, allocator, options); }
        public void Dispose() { ListData.Dispose(); }
        public JobHandle Dispose(JobHandle inputDeps) { return ListData.Dispose(inputDeps); }
        public void Clear() { ListData.Clear(); }
        public void Resize(int length, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { ListData.Resize<<#=type#>>(length, options); }
        public void SetCapacity(int capacity) { ListData.SetCapacity<<#=type#>>(capacity); }
        public int IndexOf(<#=type#> value) { return ListData.IndexOf(value); }
        public bool Contains(<#=type#> value) { return ListData.Contains(value); }
        public void Add(<#=type#> value) { ListData.Add(value); }
        public void AddRange(Unsafe<#=typeName#>List src) { ListData.AddRange<<#=type#>>(src.ListData); }
        public void RemoveAtSwapBack(int index) { ListData.RemoveAtSwapBack<<#=type#>>(index); }
        public ParallelReader AsParallelReader() { return new ParallelReader(Ptr, Length); }

        public unsafe struct ParallelReader
        {
            public readonly <#=type#>* Ptr;
            public readonly int Length;

            public ParallelReader(<#=type#>* ptr, int length) { Ptr = ptr; Length = length; }
            public int IndexOf(<#=type#> value) { for (int i = Length - 1; i >= 0; --i) { if (Ptr[i] == value) { return i; } } return -1; }
            public bool Contains(<#=type#> value) { return IndexOf(value) != -1; }
        }
    }

    sealed class Unsafe<#=typeName#>ListDebugView
    {
        private Unsafe<#=typeName#>List m_ListData;

        public Unsafe<#=typeName#>ListDebugView(Unsafe<#=typeName#>List listData)
        {
            m_ListData = listData;
        }

        public unsafe <#=type#>[] Items
        {
            get
            {
                var result = new <#=type#>[m_ListData.Length];
                var ptr    = m_ListData.Ptr;

                for (int i = 0, num = result.Length; i < num; ++i)
                {
                    result[i] = ptr[i];
                }

                return result;
            }
        }
    }

<#}}#>
<#
{
    foreach (var (type, typeName, typeDebugView) in new[] {
        ( "Chunk",     "Chunk",     "ArchetypeChunk"  ),
        ( "Archetype", "Archetype", "EntityArchetype" ),
        ( "EntityQueryData", "EntityQueryData", "EntityQueryData*" ),
    }) {
#>
    [DebuggerTypeProxy(typeof(Unsafe<#=typeName#>PtrListDebugView))]
    internal unsafe struct Unsafe<#=typeName#>PtrList
    {
        [NativeDisableUnsafePtrRestriction]
        public readonly <#=type#>** Ptr;
        public readonly int Length;
        public readonly int Capacity;
        public readonly Allocator Allocator;

        private ref UnsafePtrList ListData { get { return ref *(UnsafePtrList*)UnsafeUtility.AddressOf(ref this); } }

        public unsafe Unsafe<#=typeName#>PtrList(<#=type#>** ptr, int length) { Ptr = null; Length = 0; Capacity = 0; Allocator = Allocator.Invalid; ListData = new UnsafePtrList((void**)ptr, length); }
        public unsafe Unsafe<#=typeName#>PtrList(int initialCapacity, Allocator allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { Ptr = null; Length = 0; Capacity = 0; Allocator = Allocator.Invalid; ListData = new UnsafePtrList(initialCapacity, allocator, options); }
        public void Dispose() { ListData.Dispose(); }
        public JobHandle Dispose(JobHandle inputDeps) { return ListData.Dispose(inputDeps); }
        public void Clear() { ListData.Clear(); }
        public void Resize(int length, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { ListData.Resize(length, options); }
        public void SetCapacity(int capacity) { ListData.SetCapacity(capacity); }
        public int IndexOf(<#=type#>* value) { return ListData.IndexOf(value); }
        public bool Contains(<#=type#>* value) { return ListData.Contains(value); }
        public void Add(<#=type#>* value) { ListData.Add(value); }
        public void AddRange(Unsafe<#=typeName#>PtrList src) { ListData.AddRange(src.ListData); }
        public void RemoveAtSwapBack(int index) { ListData.RemoveAtSwapBack(index); }

        public unsafe struct ParallelReader
        {
            public readonly <#=type#>** Ptr;
            public readonly int Length;

            public ParallelReader(<#=type#>** ptr, int length) { Ptr = ptr; Length = length; }
            public int IndexOf(<#=type#>* value) { for (int i = Length - 1; i >= 0; --i) { if (Ptr[i] == value) { return i; } } return -1; }
            public bool Contains(<#=type#>* value) { return IndexOf(value) != -1; }
        }
    }

    sealed class Unsafe<#=typeName#>PtrListDebugView
    {
        private Unsafe<#=typeName#>PtrList m_ListData;

        public Unsafe<#=typeName#>PtrListDebugView(Unsafe<#=typeName#>PtrList listData)
        {
            m_ListData = listData;
        }

        public unsafe <#=typeDebugView#>[] Items
        {
            get
            {
                var result = new <#=typeDebugView#>[m_ListData.Length];
                var ptr    = m_ListData.Ptr;

                for (int i = 0, num = result.Length; i < num; ++i)
                {
                    result[i] = *(<#=typeDebugView#>*)ptr[i];
                }

                return result;
            }
        }
    }
<#}}#>
}
